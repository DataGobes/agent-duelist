import type { CiReport, ScorerComparison, CostSummary, ScorerStats } from '../ci.js'
import type { BenchmarkResult } from '../runner.js'
import { formatDelta } from '../utils/format.js'

export const COMMENT_MARKER = '<!-- duelist-ci-report -->'

export function markdownReporter(report: CiReport, _current: BenchmarkResult[]): string {
  const lines: string[] = [COMMENT_MARKER, '']

  // Header
  const status = report.failed ? 'ðŸ”´ Failed' : 'ðŸŸ¢ Passed'
  lines.push(`## â¬¡ Agent Duelist CI â€” ${status}`)
  lines.push('')

  // Comparison table
  if (report.comparisons.length > 0) {
    lines.push(markdownComparisonTable(report.comparisons))
    lines.push('')
  }

  // Cost summary
  if (report.cost.totalUsd > 0 || report.cost.budget !== undefined) {
    lines.push(markdownCostSummary(report.cost))
    lines.push('')
  }

  // Flakiness warnings
  if (report.flakyResults.length > 0) {
    lines.push('### âš ï¸ Flaky Results')
    lines.push('')
    lines.push('These scorer/task combinations have high variance (CV > 0.3). Consider increasing `runs` or tightening prompts.')
    lines.push('')
    for (const f of report.flakyResults) {
      lines.push(`- **${f.providerId}** Ã— ${f.taskName} â†’ ${f.scorerName} (CV = ${f.current.cv.toFixed(2)})`)
    }
    lines.push('')
  }

  // Failure reasons
  if (report.failureReasons.length > 0) {
    lines.push('### Failure Reasons')
    lines.push('')
    for (const reason of report.failureReasons) {
      lines.push(`- ${reason}`)
    }
    lines.push('')
  }

  lines.push('---')
  lines.push('*Generated by [agent-duelist](https://github.com/DataGobes/agent-duelist) CI*')

  return lines.join('\n')
}

export function markdownComparisonTable(comparisons: ScorerComparison[]): string {
  const lines: string[] = []

  lines.push('| Provider | Task | Scorer | Baseline | Current | Delta | Status |')
  lines.push('|----------|------|--------|----------|---------|-------|--------|')

  for (const c of comparisons) {
    const baselineStr = c.baseline ? formatStats(c.baseline) : 'â€”'
    const currentStr = formatStats(c.current)
    const deltaStr = c.delta !== null ? formatDelta(c.delta, 3) : 'â€”'
    const status = statusIndicator(c)

    lines.push(`| ${c.providerId} | ${c.taskName} | ${c.scorerName} | ${baselineStr} | ${currentStr} | ${deltaStr} | ${status} |`)
  }

  return lines.join('\n')
}

export function markdownCostSummary(cost: CostSummary): string {
  const lines: string[] = []

  lines.push('### ðŸ’° Cost Summary')
  lines.push('')
  lines.push(`**Total:** $${cost.totalUsd.toFixed(4)}`)

  if (cost.budget !== undefined) {
    const pct = cost.budget > 0 ? ((cost.totalUsd / cost.budget) * 100).toFixed(0) : 'âˆž'
    const indicator = cost.overBudget ? 'ðŸ”´' : 'ðŸŸ¢'
    lines.push(`**Budget:** $${cost.budget.toFixed(2)} (${pct}% used) ${indicator}`)
  }

  if (cost.perProvider.size > 1) {
    lines.push('')
    lines.push('| Provider | Cost |')
    lines.push('|----------|------|')
    for (const [provider, usd] of cost.perProvider) {
      lines.push(`| ${provider} | $${usd.toFixed(4)} |`)
    }
  }

  return lines.join('\n')
}

function formatStats(stats: ScorerStats): string {
  if (stats.n > 1) {
    const margin = (stats.ci95Upper - stats.ci95Lower) / 2
    return `${stats.mean.toFixed(3)} Â± ${margin.toFixed(3)}`
  }
  return stats.mean.toFixed(3)
}

function statusIndicator(c: ScorerComparison): string {
  if (c.regressed) return 'ðŸ”´ regressed'
  if (c.improved) return 'ðŸŸ¢ improved'
  if (c.baseline === null) return 'ðŸ†• new'
  return 'âšª unchanged'
}
